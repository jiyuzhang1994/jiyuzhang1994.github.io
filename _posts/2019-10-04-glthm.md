---
layout: default
permalink: /glthm/
title: Goldreich Levin Theorem
tags: Cryptography
---

In this blog we study and present the proof of Goldreich-Levin theorem. The main material we use is the  course notes of Prof. Luca Trevisan (See references below).  

The Goldreich-Levin Theorem has several interpretations. We will first explain and prove it from cryptographic view. Then we will see in fact it can also be viewed as list-decoding of Hadamard code.

## Background
In this section we present necessary definitions and math inequalities we will be using.  

**Theorem 1 (Markov Inequality)**

**Theorem 2 (Chernoff Bound)**  
Suppose $X_1, \ldots, X_k$ are 0, 1 *i.i.d* random variables and $ X = \sum_i^{k} X_i$, then for any $0<\epsilon<1$:  

$$Pr[\ X>(1+\epsilon)E[X]\ ]<e^{-\frac{\epsilon^2}{3}\cdot E[X]}$$  

$$Pr[\ X<(1-\epsilon)E[X]\ ]<e^{-\frac{\epsilon^2}{3}\cdot E[X]}$$

**Definition 1 (Hard-Core Predicate)** A boolean function $$P: \{0, 1 \}^n \rightarrow \{0, 1\}$$ is $(t, \epsilon)$ - hard core for a permutation $$f: \{0,1\}^n \rightarrow \{0,1\}$$ if for every algorithm $A$ of complexity $t$  

$$Pr_{x\sim \{0, 1\}}[A(f(x)) = P(x)]\leq \frac{1}{2}+\epsilon$$


## Goldreich Levin Theorem

The Goldreich-Levin theorem says that a random XOR is hard-core for every one-way permutation. We denote inner product modulo 2 using the following notation:  

$$\langle x,r\rangle = \sum_i x_i\cdot r_i\ mod\ 2$$

**Theorem 1 (Goldreich-Levin Theorem)** *Suppose $A$ is an algorithm of complexity $t$ such that*  

$$Pr_{x, r} [A(f(x),r)\ =\ \langle x ,r\rangle] \geq \frac{1}{2} + \epsilon$$  

*Then there is an algorithm $A^\prime$ of complexity at most $O(t\epsilon^{-2}n^{O(1)})$ such that* 

$$Pr_x[A^\prime(f(x)) = x] \geq \Omega(\epsilon)$$

We will first prove a weak Goldreich-Levin algorithm, which will later be used in our proof of GL theorem.

**Theorem 2 (Goldreich-Levin Algorithm Weak Version)** *Suppose there is a function $H$ such that, for some $x$*  

$$Pr_r[H(r)\ =\ \langle x,r\rangle]\ \geq \frac{3}{4} + \epsilon$$

*Then there is an algorithm $GLW$ that can output $x$ with high probability ( $\geq 1-\frac{1}{n}$ ).*  

Let's first see how an easy algorithm can find $x$ when the probability on the right side is 1 in the above (so that $H(r)$ outputs $\langle x,r\rangle$ correctly).  

Let $e_i$ denote the vector in which the $i$th bit is 1 and 0 otherwise. $x_i = H(e_i) = \langle x, e_i \rangle$. Then we can output $x$ by enumerating all the $e_i$.   

Now to prove Theorem 2, note that $H(r)$ fails with small probability, we'll use the majority vote method. Intuitively,  we randomly sample several points $r_1 \ldots r_k$. Let $H^\prime_{r_1 \ldots r_k}(e_i)$ be the function that take the majority of  $H(r_i+e_i) - H(r_i)$ on these $r_i$s. The observation is that if $H(r)$ computes $\langle x, r\rangle$ correctly, then we have:

$$ \langle x, r_i+e_i \rangle - \langle x, r_i \rangle = \langle x, e_i\rangle$$

We now bound the probability that $H(r_i + e_i) - H(r_i)$ fails.  

$$\begin{align*}
  Pr[H(r_i + e_i) - H(r_i) \neq  \langle x, e_i\rangle] &= Pr[H(r_i + e_i) \neq \langle x, r_i+e_i \rangle\ \cup H(r_i) \neq \langle x, r_i \rangle]\\
  &\leq Pr[H(r_i + e_i) \neq \langle x, r_i+e_i \rangle]\ + Pr[H(r_i) \neq \langle x, r_i \rangle]\\
  &\leq \frac{1}{4} - \epsilon + \frac{1}{4} - \epsilon\\
  &\leq \frac{1}{2} - 2\epsilon
 \end{align*}$$
 
The GLW algorithm is as follows:
 
 * GLW Algorithm:
 * for $i= 1, 2, \ldots , n$:  
     * for $j = 1, 2, \ldots , 2\log n$:  
     * randomly sample $$r_j\in \{0, 1\}^n$$
     * compute $H(r_j + e_i) - H(r_j)$
 * compute $x_i = H^\prime_{r_1 \ldots r_k}(e_i) = Majority\{H(r_j + e_i) - H(r_j): r_j = 1, 2, \ldots , 2\log n \}$  
 * return $x$  

Now we analyze this algorithm. Since each $H(r_j + e_i) - H(r_j)$ outputs the correct answer with probability at least $1/2 + 2\epsilon$. By the Chernoff Bound (Theorem 2 in Background), the probability that the majority function $H^\prime_{r_1 \ldots r_k}(e_i)$ fails to output $x_i$ is at most $e^{-\Omega(2\log n)} = O(\frac{1}{n^2})$. Then the union bound gives us that GLW outputs $x$ correctly with probability at least $1-1/n$. The algorithm runs in time $O(n^2 \log n)$, makes $O(n\log n)$ queries to $H$.

## References
Lecture Notes 11, 12 of Luca Trevisan's Spring 2009 Cryptography Courses, see this [Link](https://people.eecs.berkeley.edu/~luca/cs276/#notes).