---
layout: default
permalink: /zknotes/
title: Some Notes on Zero Knowledge Proofs
---

I'm reposting this to clearify questions I had when study these notes. I'll be using the conventional notations in [1].

There are two properties that Interactive Proofs must satisfy. Informally, a good interactive proof system for a language $L$ consists of a pair of prover and verifier $(P, V)$ that satisfies the following:

1. if $x\in L$, then there is a very large probability that $V$ accepts. (the **completeness**)  
2. if $x\not\in L$, then a malicious prover has very tiny chance to convince $V$ that $x\in L$. ( the **soundness**)  

Things to note: First, the prover is usually assumed to have unbounded computational power. Second, a malicious prover (say Alice) means that she can make changes by herself and doesn't necessarily follow the protocol.  


Zero knowledge proof is, a proof that doesn't convey any knowledge but that the statement is true. In order to achieve this, the definition needs to be a little bit subtle.  

As [1] suggests, "A conversation therefore conveys knowledge when the conversation allows the recipient to complete a “new” task that the recipient could not complete before".

In the computational world, "The amount of knowledge conveyed in a message can be quantified by considering the running time and size of a Turing machine that generates the message". Therefore, the zero knowledge can mean that what you see doesn't give you extra power to compute something. That is, the verifier can't compute anything new given the messages communicated between the two parties.  

It turns out that this is modeled by showing that, for any adversarial p.p.t. verifier $$V^*$$ who tries to extract knowledge from the interaction, there exists a p.p.t. simulator $$S^*$$ such that the following distribution is computationally indistinguishable:  

1. $View[P(x) \leftrightarrow V^*(x)]$  
2. $S^*(x)$  

Informally, whatever Alice can learn can be produced by herself. So Alice can essentially simulate the interaction independently.  

The following are some important notes I'd like to make.

**Requiring the output of $$S^*$$ to include $$V^*$$'s randomness**

One thing [1] doesn't specify is that the simulator necessarily needs to output the randomness the verifier is using. This is justified in [2] by giving an example of an interactive proof for graph isomorphism. The example shows the following:  

1. the protocol enables the verifier to learn the isomorphism (the witness) the prover holds.  

2. there exists a perfect simulator if we don't require the simulator to output the randomness of the verifier.  

Readers should refer to page 7-6 of [2] to see the example. We only explained what properties the protocol has.

**The power of simulator**

Another question we might have is: since a language equiped with a zk proof has a simulator, then it should be possible for a malicious prover to utilize this simulator to cheat the verifier, which seems to immediately contradict the soundness.



**References**  
[1] R.Pass & A.Shelat. A Course in Cryptography.  
[2] Rafail Ostrovsky. Foundations of Cryptography Draft Lecture Notes.  
