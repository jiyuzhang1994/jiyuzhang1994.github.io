<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Hash Function for Cryptocurrency &middot; Jiyu Zhang
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script>
   <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         processEscapes: true
       }
     });
   </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body class="theme-base-0d">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Jiyu Zhang
        </a>
      </h1>
      <p class="lead">Contact: <br /> zjy9462 at gmail dot com</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item active" href="/">About Me</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
    </nav>

    <p>&copy; 2019. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <p>Cryptocurrency relies on special cryptographic hash functions with nice properties. Today I’d like to explain these properties and discuss their applications.  This notes refered to &lt; Bitcoin And Cryptocurrency Technologies A Comprehensive Introduction &gt; by Bonneau et al.</p>

<p>A <em>hash function</em> is an efficiently computable function <script type="math/tex">H: \{0,1\}^*\rightarrow \{0,1\}^k</script> where $k$ is a fixed parameter. That is</p>
<ol>
  <li>Its input can be of string of any size.</li>
  <li>Its output is of fixed length, usually set to be 256 bits.</li>
  <li>It is efficiently computable.</li>
</ol>

<p>While to be useful for cryptocurrency, it requires the hash function to be of special <em>cryptographic</em> hash function. Specifically, the following three properties hold: (1) Collision resistant;  (2) Hiding; (3) Puzzlefriendliness.</p>

<p>I’ll explain these properties in detail.</p>

<h2 id="property-1-collision-resistant">Property 1: Collision Resistant</h2>

<p><strong>Definition.</strong> <em>(Collision Resistant)</em> A hash function $H$ is said to be <em>Collision Resistant</em> if it is <strong>infeasible to find</strong> two values $x$ and $y$, such that $x\neq y$ yet $H(x) = H(y)$.</p>

<p>The following notes are made:</p>
<ol>
  <li>Collision exists as long as the input set size is larger than the output set size.</li>
  <li>There is a trivial algorithm to find a collision for a (say) 256-bit output: pick $2^{256}+1$ distinctive values, compute the hashes for each of them and check equivalence for each pair. However, this method will take more than octillion years before finding such a pair. And we consider this method <strong>not feasible</strong>.</li>
  <li>No hash functions have been proved to be collision resistant. i.e, there is possibility that there exists efficient (feasible) algorithm to find collisions. The hash functions we rely on in practice are those people have tried very very hard to find a method to break (i.e. find an efficient algorithm to compute collisions).</li>
</ol>

<h3 id="application-online-file-storage">Application: Online File Storage</h3>
<p>The collision resistant property can be used in the following logic: If one knows $x$ and $y$ are different, then it’s safe to say $H(x)$ and $H(y)$ are different. This can be confirmed by a contradictory argument. If one knows/can find/can compute a pair of $x$ and $y$ s.t $x\neq y$ and $H(x) = H(y)$, this violates our assumption that $H$ is collision resistant.</p>

<p>Now one application of this logic is <em>Online File Storage</em>. Suppose you have a very large file and would like to upload it to a online file storage system so that you can download it later, possibly on another computer. How can you be sure that the file you download later is the same as you uploaded. One way is to store the file locally and compare it with the downloaded version bit by bit. Well, this may not be efficient since the file is very large. However, if you only store the hash of the file locally, and compare it with the hash of the file you downloaded, it is much more efficient. And the collision resistant property guarantees that, the system is hard to find a different file and its hash is the same as that of the one you uploaded.</p>

<p>This is like you’re memorizing a specifc sign of your item while no one can find a fake item that has the sign as yours. When you get it back, you just examine this sign and figure out whether it is indeed the item you stored.</p>

<h2 id="property-2-hiding">Property 2: Hiding</h2>

<p>Informally the hiding property says that if one is given the output of the hash function $y=H(x)$, he is infeasible to find the value of $x$. Again, there is a trivial way to find $x$, just try all the possible $x$ and compute $H(x)$ to find the specific $x$ with $y=H(x)$. Note here we don’t take the case where $x\neq x^\prime$ and $y=H(x)=H(x^\prime)$ into consideration.</p>

<p>So one way to implement this property is to make the input set large enough so it takes “infeasible” time to use the above algorithm. But we want to do this with a small input set, and this can be done by concatenating the input with a random string. Formally,</p>

<p><strong>Definition.</strong> <em>(Hiding)</em> A hash function $H$ is said to be <em>Hiding</em> if when a secret value $r$ is chosen from a probability distribution that has <em>high min-entropy</em>, then given $H(r||x)$, it’s infeasible to find $x$.</p>

<p>The definition of min-entropy can be found in many text books , for example, at <a href="http://people.seas.harvard.edu/~salil/pseudorandomness/">here</a>. Informally, a distribution with <em>high min-entropy</em> means that the distribution is close to “flat”, i.e. each of the event has almost identical chance to happen.</p>

<h3 id="application-commitment-digital-envelope">Application: Commitment (Digital Envelope)</h3>

<p>A commitment, also called a digital envelope, is the abstraction of taking a value $x$ and put it into an envelope then send it to a receiver. Later the sender can reveal the value in the envelope to the receiver. Informally, two properties are required for a commitment:</p>

<ol>
  <li>Hiding. No one is able to figure out the value $x$ when the value is not revealed.</li>
  <li>Binding. After the sender has made a commitment, he is not able to change the value in the envelope.</li>
</ol>

<p>Formally, a commitment scheme consists of two algorithms:</p>

<ul>
  <li>commit(msg, nonce) The commit function takes as input a message and a secret random value nonce then return a commitment.</li>
  <li>verify(com, msg, nonce) The verify function takes as input a commitmentm, a message and a nonce. It return true iff com == commit(msg, nonce).</li>
</ul>

<p>The hiding and binding property can be formalized as following:</p>

<ol>
  <li>Hiding. Given $com$, it is infeasible to find $msg$.</li>
  <li>Binding. It is infeasible to find two pairs <script type="math/tex">(msg, nonce)</script> and $(msg^\prime, nonce^\prime)$ such that $msg\neq msg^\prime$ and $commit(msg, nonce) == commit(msg^\prime, nonce^\prime)$.</li>
</ol>

<p>Note that the $nonce$ and $nonce^\prime$ is not necessarily the same. Also $nonce$ can only be used once.</p>

<p>To use a commitment scheme, the sender first generate a random $nonce$, then apply $commit$ to $msg$ and $nonce$ and return $com$. Later when the sender wants to reveal $msg$, he publishes the $nonce$ and the $msg$, others can verify $msg$ is indeed what the sender has commited using $verify$.</p>

<p><strong>Implementation</strong></p>

<p>Commitment can be implemented using cryptographic hash function.</p>

<ul>
  <li>$commit(msg, nonce) = H(msg||nonce) = com$</li>
  <li>$verify(com, msg, nonce) = (boolean)\ (H(msg||nonce) == com)$</li>
</ul>

<p>It is an easy practice to check that the <em>Hiding</em> property of $H$ implies the hiding property of the commitment. The <em>Binding</em> property is implied by the <em>Collision Resistant</em> property of $H$.</p>

<h2 id="property-3-puzzle-friendliness">Property 3: Puzzle Friendliness</h2>

<p>sdf</p>

    </div>

  </body>
</html>
