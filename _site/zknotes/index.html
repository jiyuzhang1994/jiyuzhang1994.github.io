<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Some Notes on Zero Knowledge Proofs &middot; Jiyu Zhang
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script>
   <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         processEscapes: true
       }
     });
   </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body class="theme-base-0d">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Jiyu Zhang
        </a>
      </h1>
      <p class="lead">Contact: <br /> zjy9462 at gmail dot com</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item active" href="/">About Me</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
      <a class="sidebar-nav-item" href="/Notes/">Notes</a>
      <a class="sidebar-nav-item" href="/Links/">Links</a>
      <a class="sidebar-nav-item" href="/Misc/">Misc</a>
    </nav>

    <p>&copy; 2020. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <p>I’m reposting this to clearify questions I had when study these notes. I’ll be using the conventional notations in [1].</p>

<p>There are two properties that Interactive Proofs must satisfy. Informally, a good interactive proof system for a language $L$ consists of a pair of prover and verifier $(P, V)$ that satisfies the following:</p>

<ol>
  <li>if $x\in L$, then there is a very large probability that $V$ accepts. (the <strong>completeness</strong>)</li>
  <li>if $x\not\in L$, then a malicious prover has very tiny chance to convince $V$ that $x\in L$. ( the <strong>soundness</strong>)</li>
</ol>

<p>Note that, in completeness, we consider both honest prover and honest verifier. The honest prover may be either computationally bounded or computationally unrestricted depending on the model we concern. In soundness, we consider malicious prover who can arbitrarily deviate from the protocol, and is computationally unrestricted. The verifier is considered to be honest in this case.</p>

<p>Zero knowledge proofs are, interactive proofs with an additional property called the zero knowledge property. The property says that in the interaction the prover doesn’t convey any knowledge but that the statement is true. In order to achieve this, we need to carefully define what is “knowledge”.</p>

<p>As [1] suggests, “A conversation therefore conveys knowledge when the conversation allows the recipient to complete a “new” task that the recipient could not complete before”.</p>

<p>In the computational world, “The amount of knowledge conveyed in a message can be quantified by considering the running time and size of a Turing machine that generates the message”. Therefore, the zero knowledge can mean that what you see doesn’t give you extra power to compute something. That is, the verifier can’t compute anything new given the messages communicated between the two parties.</p>

<p>It turns out that this (zero knowledge) is modeled by showing that, for any adversarial p.p.t. verifier <script type="math/tex">V^*</script> who tries to extract knowledge from the interaction, there exists a p.p.t. simulator <script type="math/tex">S^*</script> such that the following distributions are computationally indistinguishable:</p>

<ol>
  <li>$View[P(x) \leftrightarrow V^*(x)]$</li>
  <li>$S^*(x)$</li>
</ol>

<p>Informally, <strong>whatever Alice learns in the process can be produced by herself</strong>. So Alice can essentially simulate the interaction independently.</p>

<p>The following are some important notes I’d like to make.</p>

<h2 id="requiring-s-to-ouputcompute-vs-randomness">Requiring <script type="math/tex">S^*</script> to ouput/compute <script type="math/tex">V^*</script>’s randomness</h2>

<p>One thing [1] doesn’t specify is that the simulator necessarily needs to output the randomness the verifier is using. This is justified in [2] by giving an example of an interactive proof for graph isomorphism. The example shows the following:</p>

<ol>
  <li>
    <p>the protocol enables the verifier to learn the isomorphism (the witness) the prover holds.</p>
  </li>
  <li>
    <p>there exists a perfect simulator if we don’t require the simulator to output the randomness of the verifier.</p>
  </li>
</ol>

<p>Readers should refer to page 7-6 of [2] to see the example. We only explained what properties the protocol has.</p>

<h2 id="the-power-of-simulator">The power of simulator</h2>

<p>Another question we might have is: since a language equiped with a zk proof has a simulator, then it should be possible for a malicious prover to utilize this simulator to cheat the verifier, which seems to immediately contradict the soundness. The answer is that, the simulator is usually allowed to do more than what the prover can do. Specifically, the simulator can <strong>rewind</strong> the verifier.</p>

<p>Rewinding means that the simulator may essentially query the verifier from any previous internal states of it. In contrast, the real prover is defined not to be able to do this. <strong><em>What we can ask</em></strong> is why this model is of interest. An example is that you can consider the situation when you (a real prover) are entering a system and you’re asked to answer a sequence of questions. If in some steps you say:”I want to go back to one of the previous questions, forget what I said just now.” Then this immediately causes the doubt of the verifier and it may simply halt and reject it.</p>

<p>To remark, the simulator lives in the same world as the verifier does. They have the same auxiliary input. The simulator can rewind the verifier, and can be quantum if the verifier is quantum.</p>

<p>Some remarks that might be helpful for understanding can be found at page 18 of [3]</p>

<p><strong>References</strong><br />
[1] R.Pass &amp; A.Shelat. A Course in Cryptography.<br />
[2] Rafail Ostrovsky. Foundations of Cryptography Draft Lecture Notes.<br />
[3] Yehuda Lindell. How To Simulate It – A Tutorial on the Simulation Proof Technique. https://eprint.iacr.org/2016/046.pdf</p>

    </div>

  </body>
</html>
